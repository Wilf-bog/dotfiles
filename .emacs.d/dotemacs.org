#+title: Emacs configuration
#+author: Frédéric Vachon
#+property: header-args:emacs-lisp :mkdirp yes
#+startup: content indent

This is a new configuration for my own personal use of Emacs starting
on September 1st of 2025. After a few years of playing with Emacs,
using distributions, and copying code from a variety of sources, I've
decided it was finally time to start afresh and actually write my very
own personal configuration. I'll probably keep on integrating code
from other configurations, but the goal is to be more careful and
meticulous in my use of external code. Hopefully, this configuration
will remain short enough to be manageable for me, considering my
limited time and abilities. This whole decision is partly inspired by
Jake's video on Emacs Bankruptcy which can be watched here:
[[https://www.youtube.com/watch?v=dSlMmCD5quc&t=200s][Emacs bankruptcy
– fix your Emacs and your life]].

This configuration takes inspiration of a few Emacs users I've been
following over the years and I would like to thank them for their
contribution.
- Protesilaos Stavrou

* Early initialization of Emacs (=early-init.el=)

#+begin_src emacs-lisp :tangle early-init.el
;; Copyright (C) 2025  Frédéric Vachon

;; Author: Frédéric Vachon <vachonfrederic@proton.me>

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+end_src

This is a new concept to me as I didn't use an =early-init.el= file
before. From my understanding, since Emacs 27, this file is used to
push configuration that are loaded very early during Emacs'
initialization.

I took heavy inspiration (understand, copying) from Prot's own
configuration here, removing what seems to be pertinent in my own
situation. I kept some settings useful in a tiling window manager
configuration, like frame-resize-pixelwise, even though I tend to only
use Gnome these days. Sway may make a return someday and I would
rather avoid having to play with these settings later on.

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq frame-resize-pixelwise t
        frame-title-format '("%b")	; Name of file as the title of the frame
        use-file-dialog nil
        use-short-answers t
        inhibit-startup-screen t
        inhibit-x-resources t
        inhibit-startup-echo-area-message user-login-name
        inhibit-startup-buffer-menu t
        visible-bell t
        )
#+end_src

To make things faster at startup and for my own personal preferences,
I disable early on the GUI parts of emacs.

#+begin_src emacs-lisp :tangle "early-init.el"
      ;; (push '(menu-bar-lines . 0) default-frame-alist)
      ;; (push '(tool-bar-lines . 0) default-frame-alist)
      ;; (push '(vertical-scroll-bars . nil) default-frame-alist)

  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

This is mysterious for me, but these settings for garbage-collection
should help with faster boot time.

#+begin_src emacs-lisp :tangle "early-init.el"
(setq gc-cons-threshold (* 10 128 1024 1024))
(setq garbage-collection-messages nil)
#+end_src

Some settings related to packages, taken directly from crafted-emacs
modules about early-init.

#+begin_src emacs-lisp :tangle early-init.el

  (require 'package)

  ;;; Setup Emacs Lisp Package Archives (ELPAs)
  ;; where to get packages to install
  (when (version< emacs-version "28")
    (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/")))
  (add-to-list 'package-archives '("stable" . "https://stable.melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

  ;;; Configure ELPA priorities
  ;; Prefer GNU sources and stable versions before development versions from MELPA.
  (customize-set-variable 'package-archive-priorities
                          '(("gnu"    . 99)   ; prefer GNU packages
                            ("nongnu" . 80)   ; use non-gnu packages if
                                          ; not found in GNU elpa
                            ("stable" . 70)   ; prefer "released" versions
                                          ; from melpa
                            ("melpa"  . 75)))  ; if all else fails, get it
                                          ; from melpa
#+end_src

* TODO Emacs settings (=init.el=)

#+begin_src emacs-lisp :tangle init.el
;; Copyright (C) 2025  Frédéric Vachon

;; Author: Frédéric Vachon <vachonfrederic@proton.me>

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+end_src

In this larger part of my configuration, I list out all the settings
that are part of the normal initialisation process as well as settings
proper to Emacs' own packages.

** Setting Use-package

First, this line force the use of use-package. I'm not sure if it is
necessary anymore but it doesn't hurt to keep it (as far as I know).

#+begin_src emacs-lisp :tangle init.el
  ;; Built-in since Emacs 29
  (require 'use-package)
#+end_src

** TODO Setting up Emacs server for =org-protocol=
:PROPERTIES:
:ID:       974b41b3-86e8-405f-a9cc-f48c05ed1c07
:END:

The following code has been provided by this page [[https://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol.el –
Trigger actions in Emacs via a custom URL scheme]] to make it possible
to run =org-protocol=.

#+begin_src emacs-lisp :tangle init.el
(server-start)
(require 'org-protocol)
#+end_src
** =which-key=

Not necessary, but a nice addition, especially when using tools I'm
less familiar with.

#+begin_src emacs-lisp :tangle init.el
  (which-key-mode)
#+end_src

** Vertico related Emacs settings

To use vertico at its fullest, it's better to set this package so
history isn't lost when restarting Emacs.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package savehist
    :init
    (savehist-mode))
#+end_src

Again for Vertico, we do need to change some configuration.

#+begin_src emacs-lisp :tangle init.el
  ;; Emacs minibuffer configurations.
  (use-package emacs
    :custom
    ;; Enable context menu. `vertico-multiform-mode' adds a menu in the minibuffer
    ;; to switch display modes.
    (context-menu-mode t)
    ;; Support opening new minibuffers from inside existing minibuffers.
    (enable-recursive-minibuffers t)
    ;; Hide commands in M-x which do not work in the current mode.  Vertico
    ;; commands are hidden in normal buffers. This setting is useful beyond
    ;; Vertico.
    (read-extended-command-predicate #'command-completion-default-include-p)
    ;; Do not allow the cursor in the minibuffer prompt
    (minibuffer-prompt-properties
     '(read-only t cursor-intangible t face minibuffer-prompt))
    :bind
    (;; Keymap for buffers (Emacs28)
     :map ctl-x-x-map
     ("f" . follow-mode)  ; override `font-lock-update'
     ("r" . rename-uniquely)
     ("l" . visual-line-mode)))
#+end_src

** TODO Backup and lockfiles

# Considering I'm relying on syncthing to be able to share files between
# computers and that my files are auto-saved, lockfiles and backups are
# always been a bit messy. Let's see if disabling those will help with
# that (as well as cleaning my directories!)

I tried for a moment to disable backup files in general, but I learned
from
https://git.sr.ht/~technomancy/better-defaults/tree/main/item/better-defaults.el
that you can specify a specific directory to hold the backup files,
which seems like a great idea to avoid moving those files around with
Syncthing.

#+begin_src emacs-lisp :tangle init.el
  (setq make-backup-files t)
  (setq backup-inhibited nil) ; Not sure if needed, given `make-backup-files'
  (setq create-lockfiles nil)

  (unless backup-directory-alist
    (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                   "backups")))))
#+end_src

** Emacs settings about reverting

Considering I work on multiple machines, sometimes at the same time,
and that I rely on Git for many config files, I prefer to
automatically revert the buffers I'm using (files and dired buffers
for example.

#+begin_src emacs-lisp :tangle init.el
  ;; Revert buffers when the underlying file has changed
  (global-auto-revert-mode 1)
  
  ;; Revert Dired and other buffers
  (setq global-auto-revert-non-file-buffers t)

  ;; Auto-save mode for org files
  (auto-save-visited-mode +1)
  (setq auto-save-visited-predicate
	(lambda () (eq major-mode 'org-mode)))
#+end_src

To be able to use the newly added bookmarks, this settings make them
immediately available.

#+begin_src emacs-lisp :tangle init.el
  (customize-set-variable 'bookmark-save-flag 1)
#+end_src

** Using ibuffer for the buffer list

I rarely make a list of buffers (with =C-x C-b=) but clearly,
~ibuffer~ is a better tool so let's use it instead for that purpose. I
could give it a try more regularly.

Based on Prot's video, this can be very powerful to edit multiple
buffers at the same time, combined with occur for example. See:
https://www.youtube.com/watch?v=6KN_oSLFf-k.

#+begin_src emacs-lisp :tangle init.el
  (global-set-key [remap list-buffers] 'ibuffer)
#+end_src

** Emacs custom-file

Departing from Emacs Writing Studio defaults, I prefer to stop using
Emacs' config file way of managing settings. Like Prot, I ask Emacs to
rely a temporary file that won't be automatically reloaded.

#+begin_src emacs-lisp :tangle "init.el"
(setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** Emacs windows settings

I used to use a =M-o= to switch window quickly but in line with my
goal of keeping things minimal and to stay close to Emacs' defaults, I
want to get used to =C-x o=. I also used to use a package called
=balanced-windows= but again I'm tempted to stay away from it for the
moment, and get used to the command =C-x += which is the default
keybinding to balance windows.

For now, no settings are changed until I decide I want to go back to
my old ways.

** Emacs tabs

I used to use tabs with the defaults options, which means the tabs are
shown when used, and a button is used to delete tabs and another, to
create a new one. By digging into Prot's configurations, I found out
that it could be better to hide those buttons to avoid using the mouse
for tabs management and learning the correct keybindings. We will see
if it is actually useful since I do intend on trying to use Prot's
package ~beframe~.

#+begin_src emacs-lisp :tangle init.el
  (use-package tab-bar
    :ensure nil
    :config
    (setq tab-bar-new-button-show nil)
    (setq tab-bar-close-button-show nil)
    (setq tab-bar-show 1))
#+end_src

** TODO Use-package settings

For the moment, my configuration rely only on usepackage that I find
intuitive. To avoid dealing with long init time, I manually add ensure
to all cases of use-package when it's pertinent.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package use-package
    :custom
    (use-package-always-ensure nil)	; older config had it true.
    (package-native-compile t)
    (warning-minimum-level :emergency))
#+end_src

** TODO Emacs Web Wowser
Mostly known as EWW, it's the web browser to use on Emacs. I do enjoy
it to read my RSS articles.

#+begin_src emacs-lisp :tangle init.el

#+end_src

** TODO Emacs theme settings

To avoid getting asked about trusting themes, we can tell it to treat
all themes as safe by default. I use only a few themes.

#+begin_src emacs-lisp :tangle "init.el"
  (setq custom-safe-themes t)
#+end_src

*** Modus themes

I absolutely love Prot's Modus themes, especially Modus Vivendi. I
used to use to tinted version but these days I like the simplicity of
the original. I implemented shortcuts to help me switch theme easily,
inspired by ~Emacs Writing Studio~.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package modus-themes
    :custom
    (modus-themes-italic-constructs t)
    (modus-themes-bold-constructs t)
    (modus-themes-mixed-fonts t)
    (modus-themes-to-toggle
     '(modus-operandi modus-vivendi))
    (modus-themes-variable-pitch-ui t)
    (modus-themes-completions '((t . (bold))))
    (modus-themes-prompts '(bold))
    (modus-themes-headings
        '((agenda-structure . (variable-pitch light 2.2))
          (agenda-date . (variable-pitch regular 1.3))
          (t . (regular 1.15))))
    :init
    (load-theme 'modus-vivendi :no-confirm)
    :bind
    (("C-c t t" . modus-themes-toggle)
     ("C-c t m" . modus-themes-select)
     ("C-c t s" . consult-theme)))
#+end_src

*** Auto-dark

I do prefer to switch theme based on light conditions, with Gnome. For
this, I rely on the Auto-dark package. So far it works perfectly well.

#+begin_src emacs-lisp :tangle init.el
  (use-package auto-dark
    :ensure t
    :custom
    (auto-dark-themes '((modus-vivendi) (modus-operandi)))
    (auto-dark-polling-interval-seconds 5)
    (auto-dark-allow-powershell nil)
    :init (auto-dark-mode))
#+end_src

** Recent files

Emacs Writing Studio used to introduce some basic settings and
especially a keybinding to list recently edited files. Considering
~consult-buffer~ does a great job to present me the recently edited
file, I didn't had a need for a specific keybinding. Prot's settings
seem perfectly good for my own needs, with a few minor tweaks.

#+begin_src emacs-lisp :tangle init.el
  ;; Recent files

  (use-package recentf
    :ensure nil
    :hook (after-init . recentf-mode)
    :config
    (setq recentf-max-saved-items 100)
    (setq recentf-save-file-modes nil)
    (setq recentf-keep nil)
    (setq recentf-auto-cleanup nil)
    (setq recentf-initialize-file-name-history nil)
    (setq recentf-filename-handlers nil)
    (setq recentf-show-file-shortcuts-flag nil)) ; I don't use the recentf tool.
#+end_src

** TODO Text mode
In this section, I'm taking inspiration from Prot's configuration to
improve the experience of writing prose in Emacs. The reasoning comes
from my experience trying to use =fill-mode= like Prot to make reading
prose in text files easier outside of Emacs. After that, I wanted to
make use of =forward-sentence= and =backward-sentence= but I quickly
noticed it didn't work, Emacs considering by default that two spaces
are separators between sentences, which is not a common practice here
at all.

I decided to keep some additional settings Prot added, like the
ability to use text-mode based on the title of a file that may not use
the usual filetypes, like org, txt, etc. I also decided to make use of
=auto-fill-mode= at all times since I appreciate its use after a few
weeks of using the command =fill-paragraph=.

#+begin_src emacs-lisp :tangle init.el
;;;; Plain text (text-mode)
(use-package text-mode
  :ensure nil
  :mode "\\`\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)\\'"
  :hook
  ((text-mode . turn-on-auto-fill)
   (prog-mode . (lambda () (setq-local sentence-end-double-space t))))
  :config
  (setq sentence-end-double-space nil)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t))
#+end_src

*** TODO Cycling through different paragraph formats

There are a few options to be able to easily toggle between filled and
unfilled text. This package allows us to unfill a region, a paragraph, etc.

#+begin_src emacs-lisp :tangle init.el
  (use-package unfill
    :ensure t)
#+end_src

Sadly, it doesn't offer an easily way to cycle between options, but I
still keep it for the potentially useful =unfill-region=.

Instead, for now I'm relying on this function I took from this
exchange: [[https://emacs.stackexchange.com/a/29699][key bindings - Key mapping: Push `M-q` once for
fill-paragraph and twice for unfill-paragraph - Emacs Stack Exchange]].

#+begin_src emacs-lisp :tangle init.el
  (defun my-fill-paragraph (&optional arg)
    "Fill or unfill paragraph.  If repeated, alternate.
  A prefix arg for filling means justify (as for `fill-paragraph')."
    (interactive "P")
    (let ((fillp  (not (eq last-command 'fill-paragraph))))
      (apply (setq this-command  (if fillp 'fill-paragraph 'unfill-paragraph))
             (and fillp  arg  '(full t)))))
  (keymap-global-set "M-q" #'my-fill-paragraph)

#+end_src

I found out on Sacha's blog some code that allows for cycling through
different text formatting, something that appears to be potentially
really useful. Sadly for now, this code relies on Emacs 31 integration
of semantic line formatting. When I'll be ready to migrate to this
version, I intend on implementing this to replace above code.

#+begin_src emacs-lisp
(defvar my-repeat-counter '()
  "How often `my-repeat-next' was called in a row using the same command.
This is an alist of (cat count list) so we can use it for different functions.")

(defun my-unfill-paragraph ()
  "Replace newline chars in current paragraph by single spaces.
This command does the inverse of `fill-paragraph'."
  (interactive)
  (let ((fill-column most-positive-fixnum))
    (fill-paragraph)))

(defun my-fill-paragraph-semlf-long ()
  (interactive)
  (let ((fill-column most-positive-fixnum))
    (fill-paragraph-semlf)))

(defun my-repeat-next (category &optional element-list reset)
  "Return the next element for CATEGORY.
Initialize with ELEMENT-LIST if this is the first time."
  (let* ((counter
          (or (assoc category my-repeat-counter)
              (progn
                (push (list category -1 element-list)
                      my-repeat-counter)
                (assoc category my-repeat-counter)))))
    (setf (elt (cdr counter) 0)
          (mod
           (if reset 0 (1+ (elt (cdr counter) 0)))
           (length (elt (cdr counter) 1))))
    (elt (elt (cdr counter) 1) (elt (cdr counter) 0))))

(defun my-in-prefixed-comment-p ()
  (or (member 'font-lock-comment-delimiter-face (face-at-point nil t))
      (member 'font-lock-comment-face (face-at-point nil t))
      (save-excursion
        (beginning-of-line)
        (comment-search-forward (line-end-position) t))))

;; It might be nice to figure out what state we're
;; in and then cycle to the next one if we're just
;; working with a single paragraph. In the
;; meantime, just going by repeats is fine.
(defun my-reformat-paragraph-or-region ()
  "Cycles the paragraph between three states: filled/unfilled/fill-sentences.
If a region is selected, handle all paragraphs within that region."
  (interactive)
  (let ((func (my-repeat-next 'my-reformat-paragraph
                              '(fill-paragraph my-unfill-paragraph fill-paragraph-semlf
                                               my-fill-paragraph-semlf-long)
                              (not (eq this-command last-command))))
        (deactivate-mark nil))
    (if (region-active-p)
        (save-restriction
          (save-excursion
            (narrow-to-region (region-beginning) (region-end))
            (goto-char (point-min))
            (while (not (eobp))
              (skip-syntax-forward " ")
              (let ((elem (and (derived-mode-p 'org-mode)
                               (org-element-context))))
                (cond
                 ((eq (org-element-type elem) 'headline)
                  (org-forward-paragraph))
                 ((member (org-element-type elem)
                          '(src-block export-block headline property-drawer))
                  (goto-char
                   (org-element-end (org-element-context))))
                 (t
                  (funcall func)
                  (if fill-forward-paragraph-function
                      (funcall fill-forward-paragraph-function)
                    (forward-paragraph)))))
              )))
      (funcall func))))

(keymap-global-set "M-q" #'my-reformat-paragraph-or-region)
#+end_src

** Dired

Dired is my main non-GUI file manager, I've really learned to
appreciate it, though many additional settings are necessary to make
it shine.

First, this new function will be used to add to the normal
~dired-hide-details-information~ function, taken from EFS guides. We
define it first before adding it to Dired's configuration.

#+begin_src emacs-lisp :tangle init.el
  (defun hide-dired-details-include-all-subdir-paths ()
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward dired-subdir-regexp nil t)
	(let* ((match-bounds (cons (match-beginning 1) (match-end 1)))
	       (path (file-name-directory (buffer-substring (car match-bounds)
							    (cdr match-bounds))))
	       (path-start (car match-bounds))
	       (path-end (+ (car match-bounds) (length path)))
	       (inhibit-read-only t))
	  (put-text-property path-start path-end
			     'invisible 'dired-hide-details-information)))))
#+end_src

And now, Dired configuration.

#+begin_src emacs-lisp :tangle init.el
  (use-package dired
    :hook ((dired-mode . dired-hide-details-mode)
  	 (dired-after-readin . hide-dired-details-include-all-subdir-paths))
    :ensure nil
    :commands
    (dired dired-jump)
    :custom
    (dired-listing-switches
     "-goah --group-directories-first --time-style=long-iso") ; Customizing ls
    (dired-dwim-target t)			; Allow to move stuff from a
  					; window to another.
    (delete-by-moving-to-trash t)
    :init
    (put 'dired-find-alternate-file 'disabled nil))
  (autoload 'dired-omit-mode "dired-x")
#+end_src

** TODO Org

*** TODO Look and feel

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-startup-indented t)
    (org-hide-emphasis-markers t)
    (org-startup-with-inline-images t)
    (org-image-actual-width '(450))
    (org-fold-catch-invisible-edits 'error)
    (org-startup-with-latex-preview t)
    (org-pretty-entities t)
    (org-use-sub-superscripts "{}")
    (org-id-link-to-org-use-id t))
  #+end_src

*** TODO Tagging todos

#+begin_src emacs-lisp :tangle init.el
  ;; Org tags
  (setq org-tag-alist
  	'(;; Places
  	  ("@home" . ?H)
  	  ("@work" . ?W)

  	  ;; Activities
  	  ("@ménage" . ?m)
  	  ("@lecture" . ?l)
  	  ("@planning" . ?n)
  	  ("@writing" . ?w)
  	  ("@creative" . ?c)
  	  ("@écouter" . ?é)
  	  ("@visionner" . ?v)
  	  ("@email" . ?e)
  	  ("@calls" . ?a)
  	  ("@errands" . ?r)))

  ;; More TODO states
  (setq org-todo-keywords
  	'((sequence "TODO(t)" "NEXT(n)" "STARTED(s!)" "WAITING(w!)" "|" "DONE(d!)" "DELEGATED(é!)" "CANCELED(c!)")))
#+end_src

*** TODO Agenda

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-log-into-drawer t)
    :bind
    (("C-c a" . org-agenda)))

  (setq org-agenda-files '("~/Documentos/gtd/inbox.org"
                           "~/Documentos/gtd/gtd.org"
                           "~/Documentos/gtd/projets.org"
                           "~/Documentos/gtd/tickler.org"))

  (setq org-refile-targets '(("~/Documentos/gtd/gtd.org" :maxlevel . 2)
                             ("~/Documentos/gtd/someday.org" :level . 1)
                             ("~/Documentos/gtd/projets.org" :maxlevel . 5)
                             ("~/Documentos/gtd/tickler.org" :maxlevel . 2)))
#+end_src

*** TODO Capturing
:PROPERTIES:
:ID:       a8cdb92f-b229-4319-989b-e4f32a649d9f
:END:

This section is mostly centered around org-capture, a crucial tool to
manage my todo-list and more.

Recently, I followed the footsteps of Charles Choi and included his
template to capture web page and a corresponding =BiBTeX= entry to my
own library using =org-protocol=. See [[id:974b41b3-86e8-405f-a9cc-f48c05ed1c07][Setting up Emacs server for
=org-protocol=]] as well as [[http://yummymelon.com/devnull/storing-a-link-from-your-web-browser-to-bibtex-using-org-protocol.html][nfdn: Storing a Link from your Web Browser
to BibTeX using Org protocol]] for more details.

#+begin_src emacs-lisp :tangle init.el

  ;; Fleeting notes

  (use-package org
    :bind
    (("C-c c" . org-capture)
     ("C-c l" . org-store-link)))

  ;; Capture templates

  (setq org-capture-templates
        '(("f" "Fleeting note"
  	 item
  	 (file+headline org-default-notes-file "Notes")
  	 "- %?")
  	("p" "Permanent note" plain
  	 (file denote-last-path)
  	 #'denote-org-capture
  	 :no-save t
  	 :immediate-finish nil
  	 :kill-buffer t
  	 :jump-to-captured t)
  	("t" "New task" entry
  	 (file+headline "~/Documentos/gtd/inbox.org" "Tasks")
  	 "* TODO %i%? \n %U")
  	("r" "Read article" entry
  	 (file+headline "~/Documentos/gtd/inbox.org" "Tasks")
  	 "* %i%? \n %U")
  	("bib" "BibTex Online Entry" plain
           (file "~/Documentos/library/library.bib")
           (function (lambda ()
                       (string-join
                        (list "@Online {,"
                              "author = {%^{Author(s)}},"
                              "organization = {%^{Organization}},"
                              "title = {%:description},"
                              "url = {%:link},"
                              "date = {%<%Y-%m-%d>%?},"
                              "notes = {"
                              "%i"
                              "}"
                              "}")
                        "\n")))
           :prepend t
           :empty-lines-after 1)
  	("T" "Tickler" entry
  	 (file+headline "~/Documentos/gtd/tickler.org" "Tickler")
  	 "* TODO %i%? \n %U")))
#+end_src

*** TODO Habits

#+begin_src emacs-lisp :tangle init.el
(use-package org
  :config
  ;; Activer le module habit
  (require 'org-habit)

  ;; Optionnel : activer la colonne des graphes d'habitudes dans l’agenda
  (add-to-list 'org-modules 'org-habit t)

  ;; Quelques réglages utiles
  (setq org-habit-show-habits-only-for-today nil
        org-habit-show-all-today t
        org-habit-preceding-days 7
        org-habit-following-days 3))
#+end_src

*** Notes drawer

One thing I particularly like of Emacs Writing Studio was the ability
to easily and quickly add a note drawer under a Org header. It is
possible to add drawers with the default configuration, using =C-c x d=
but it's then necessary to name the drawer and it's going to be place
where the point is, which is not what I find the most useful.

Instead, I'm adding this function from Peter Provos.

#+begin_src emacs-lisp :tangle init.el
  ;; Notes drawers
  (defun wilf-org-insert-notes-drawer ()
    "Generate or open a NOTES drawer under the current heading."
    (interactive)
    (push-mark)
    (org-previous-visible-heading 1)
    (next-line)
    (org-beginning-of-line)
    (if (looking-at-p "^[ \t]*:NOTES:")
        (progn
          (org-fold-hide-drawer-toggle 'off)
          (re-search-forward "^[ \t]*:END:" nil t)
          (previous-line)
          (org-end-of-line)
          (org-return))
      (org-insert-drawer nil "NOTES"))
    (org-unlogged-message "Press <C-u C-SPACE> to return to the previous position."))

  (with-eval-after-load "org"
    (define-key org-mode-map (kbd "C-c C-x n") #'ews-org-insert-notes-drawer))
#+end_src

** TODO Bibtex
These settings are the one recommended by Peter Provos on his website,
see [[https://lucidmanager.org/productivity/emacs-bibtex-mode/][Manage Literature with Emacs BibTeX Mode]].

#+begin_src emacs-lisp :tangle init.el
  (use-package bibtex
    :custom
    (bibtex-dialect 'biblatex)
    (bibtex-user-optional-fields
     '(("keywords" "Keywords to describe the entry" "")
       ("file" "Link to a document file." "" )))
    (bibtex-align-at-equal-sign t))
#+end_src
* TODO External packages settings (=init.el=)

I decided to create a separate section this from the precedent to keep
a closer eye on the specific packages I'm adding to my
configuration. We will see if this will remain a sensible option as
the configuration grows.

** Fonts

In this section I set all the settings related to fonts / faces,
including the emojis for additional symbols.

*** Icons (=all-the-icons=)

In addition to normal fonts, I use ~all-the-icons~ to improve the look
and usability of tools like Dired. Nerd-icons seems to be an
alternative worth considering but I don't really have the need to
change for now. Maybe it could be worth it on Windows.

#+begin_src emacs-lisp :tangle init.el
  (use-package all-the-icons
    :ensure t)

  (use-package all-the-icons-completion
    :ensure t
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+end_src

*** COMMENT Fonts selection

Here I am setting my fonts. After some tries and errors Prot's
aporetic is the only font that manages to look good on any OS without
issues, like visual bugs on Windows or the absence of italics.

#+begin_src emacs-lisp :tangle init.el
  ;; Fonts settings

  (dolist (face '(default fixed-pitch))
    (set-face-attribute `,face nil
  		      :font "Aporetic Sans Mono"
  		      :weight 'regular
  		      :height 120))
  (set-face-attribute 'variable-pitch nil
  		    :font "Aporetic Sans"
  		    :weight 'regular
  		    :height 1.0) ; :height 1.0 fix an issue with zooming on EWW
#+end_src

*** Variable pitch

Also, to make sure I'm using variable-pitch fonts, I'm borrowing
Prot's settings for ~face-remap~ to set which modes are to use it.

#+begin_src emacs-lisp :tangle init.el
  ;;;;; `variable-pitch-mode' setup
  (use-package face-remap
    :ensure nil
    :bind ( :map ctl-x-x-map
            ("v" . variable-pitch-mode))
    :hook ((text-mode notmuch-show-mode elfeed-show-mode) . wilf/enable-variable-pitch)
    :config
    (defun wilf/enable-variable-pitch ()	;originally, named after Prot.
      (unless (derived-mode-p 'mhtml-mode 'nxml-mode 'yaml-mode)
        (variable-pitch-mode 1))))
#+end_src

*** Fontaine

#+begin_src emacs-lisp :tangle init.el
  (use-package fontaine
    :ensure t
    :config
    (setq fontaine-latest-state-file
  	(locate-user-emacs-file "fontaine-latest-state.eld"))
    (setq fontaine-presets
  	'((small
             :default-family "Aporetic Serif Mono"
             :default-height 80
             :variable-pitch-family "Aporetic Sans")
            (regular) ; like this it uses all the fallback values and is named `regular'
            (medium
             :default-weight semilight
             :default-height 115
             :bold-weight extrabold)
            (large
             :inherit medium
             :default-height 150)
  	  (reading
  	   :variable-pitch-family "Noto Serif"
             :variable-pitch-height 200)
            (presentation
             :default-height 180)
            (t
             ;; I keep all properties for didactic purposes, but most can be
             ;; omitted.  See the fontaine manual for the technicalities:
             ;; <https://protesilaos.com/emacs/fontaine>.
             :default-family "Aporetic Sans Mono"
             :default-weight regular
             :default-height 100

             :fixed-pitch-family nil ; falls back to :default-family
             :fixed-pitch-weight nil ; falls back to :default-weight
             :fixed-pitch-height 1.0

             :fixed-pitch-serif-family nil ; falls back to :default-family
             :fixed-pitch-serif-weight nil ; falls back to :default-weight
             :fixed-pitch-serif-height 1.0

             :variable-pitch-family "Aporetic Serif"
             :variable-pitch-weight nil
             :variable-pitch-height 1.0

             :mode-line-active-family nil ; falls back to :default-family
             :mode-line-active-weight nil ; falls back to :default-weight
             :mode-line-active-height 1.0

             :mode-line-inactive-family nil ; falls back to :default-family
             :mode-line-inactive-weight nil ; falls back to :default-weight
             :mode-line-inactive-height 1.0

             :header-line-family nil ; falls back to :default-family
             :header-line-weight nil ; falls back to :default-weight
             :header-line-height 0.9

             :line-number-family nil ; falls back to :default-family
             :line-number-weight nil ; falls back to :default-weight
             :line-number-height 0.9

             :tab-bar-family nil ; falls back to :default-family
             :tab-bar-weight nil ; falls back to :default-weight
             :tab-bar-height 1.0

             :tab-line-family nil ; falls back to :default-family
             :tab-line-weight nil ; falls back to :default-weight
             :tab-line-height 1.0

             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold

             :italic-family nil
             :italic-slant italic

             :line-spacing nil)))

    ;; Set the last preset or fall back to desired style from `fontaine-presets'
    ;; (the `regular' in this case).
    (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))

    ;; Persist the latest font preset when closing/starting Emacs and
    ;; while switching between themes.
    (fontaine-mode 1)

    ;; fontaine does not define any key bindings.  This is just a sample that
    ;; respects the key binding conventions.  Evaluate:
    ;;
    ;;     (info "(elisp) Key Binding Conventions")
    (define-key global-map (kbd "C-c f") #'fontaine-set-preset))
#+end_src

** TODO Casual
:PROPERTIES:
:ID:       3e2f6b84-a45a-4e30-bb60-19da3eec3b4c
:END:

#+begin_src emacs-lisp :tangle init.el
  (use-package casual
    :ensure t
    :defer t)
#+end_src

*** TODO Casual and Org-agenda

#+begin_src emacs-lisp :tangle init.el
  (require 'casual-agenda)
  (keymap-set org-agenda-mode-map "C-o" #'casual-agenda-tmenu)
#+end_src

*** TODO COMMENT Casual and Bibtex

#+begin_src emacs-lisp :tangle init.el
  (require 'casual-bibtex)
  (keymap-set bibtex-mode-map "M-m" #'casual-bibtex-tmenu)

  (add-hook 'bibtex-mode-hook 'hl-line-mode)

  (keymap-set bibtex-mode-map "<TAB>" #'bibtex-next-field)
  (keymap-set bibtex-mode-map "<backtab>" #'previous-line)

  (keymap-set bibtex-mode-map "C-n" #'bibtex-next-field)
  (keymap-set bibtex-mode-map "M-n" #'bibtex-next-entry)
  (keymap-set bibtex-mode-map "M-p" #'bibtex-previous-entry)

  (keymap-set bibtex-mode-map "<prior>" #'bibtex-previous-entry)
  (keymap-set bibtex-mode-map "<next>" #'bibtex-next-entry)

  (keymap-set bibtex-mode-map "C-c C-o" #'bibtex-url)
  (keymap-set bibtex-mode-map "C-c C-c" #'casual-bibtex-fill-and-clean)

  (keymap-set bibtex-mode-map "<clear>" #'bibtex-empty-field)
  (keymap-set bibtex-mode-map "M-<clear>" #'bibtex-kill-field)
  (keymap-set bibtex-mode-map "M-DEL" #'bibtex-kill-field)

#+end_src

** TODO Git

For git, I tend to prefer Magit even though it is probably overkill
considering my limited use of git in general. I do enjoy how the tool
is structured and until I take the time to learn Emacs own way of
managing git and other software like this, I'll keep on using Magit.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package magit
    :ensure t)

  (add-hook 'magit-process-find-password-functions
  	  'magit-process-password-auth-source)
#+end_src

** TODO Denote

One of the main reason I've switched to Emacs was how great Denote
fitted in the way I've been wanting to write notes in my daily life. I
used to use Obsidian to do so but I didn't like the fact that it was
closed-source first and the rather limited options offered by the
plugins. It always seemed a bit hacky to me and I tended to loose
control of the structure of my notes directory. Denote encourages us
to rely on it's naming format to keep things organized and I love
that. It may seem rather rigid, but it not limited to a vault and can
be used in all sorts of context. I do intend to use this fantastic
tool in the long run.

*** Denote general configuration

The configuration offered by default by Prot is good to me. My
modifications are rather minor.

#+begin_src emacs-lisp :tangle init.el
  (use-package denote
    :ensure t
    :hook
    ( ;; If you use Markdown or plain text files, then you want to make
     ;; the Denote links clickable (Org renders links as buttons right
     ;; away)
     (text-mode . denote-fontify-links-mode-maybe)
     ;; Apply colours to Denote names in Dired.  This applies to all
     ;; directories.  Check `denote-dired-directories' for the specific
     ;; directories you may prefer instead.  Then, instead of
     ;; `denote-dired-mode', use `denote-dired-mode-in-directories'.
     (dired-mode . denote-dired-mode))
    :bind
    ;; Denote DOES NOT define any key bindings.  This is for the user to
    ;; decide.  For example:
    ( :map global-map
      ("C-c n n" . denote)
      ("C-c n d" . denote-dired)
      ("C-c n g" . denote-grep)
      ;; If you intend to use Denote with a variety of file types, it is
      ;; easier to bind the link-related commands to the `global-map', as
      ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
      ;; `markdown-mode-map', and/or `text-mode-map'.
      ("C-c n i" . denote-link-or-create)
      ("C-c n l" . denote-link)
      ("C-c n L" . denote-add-links)
      ("C-c n b" . denote-backlinks)
      ("C-c n q c" . denote-query-contents-link) ; create link that triggers a grep
      ("C-c n q f" . denote-query-filenames-link) ; create link that triggers a dired
      ;; Note that `denote-rename-file' can work from any context, not just
      ;; Dired bufffers.  That is why we bind it here to the `global-map'.
      ("C-c n r" . denote-rename-file)
      ("C-c n R" . denote-rename-file-using-front-matter)

      ;; Key bindings specifically for Dired.
      :map dired-mode-map
      ("C-c C-d C-i" . denote-dired-link-marked-notes)
      ("C-c C-d C-r" . denote-dired-rename-files)
      ("C-c C-d C-k" . denote-dired-rename-marked-files-with-keywords)
      ("C-c C-d C-R" . denote-dired-rename-marked-files-using-front-matter))

    :config
    ;; Remember to check the doc string of each of those variables.
    (setq denote-directory (expand-file-name "~/Documentos/notes/"))
    (setq denote-save-buffers t)
    (setq denote-known-keywords '("emacs" "philosophy" "politics" "economics"))
    (setq denote-infer-keywords t)
    (setq denote-file-type "org")
    (setq denote-sort-keywords t)
    (setq denote-prompts '(title keywords))
    (setq denote-excluded-directories-regexp nil)
    (setq denote-excluded-keywords-regexp nil)
    (setq denote-rename-confirmations '(rewrite-front-matter modify-file-name))

    ;; Pick dates, where relevant, with Org's advanced interface:
    (setq denote-date-prompt-use-org-read-date t)

    ;; Automatically rename Denote buffers using the `denote-rename-buffer-format'.
    (denote-rename-buffer-mode 1))
#+end_src

*** Consult-denote

A very useful tool to search into the main note directory. Eventually
I would like to find a way to change the silo, but for now, it's not
necessary.

#+begin_src emacs-lisp :tangle init.el
  (use-package consult-denote
    :ensure t
    :bind
    (("C-c n F" . consult-denote-find)
     ("C-c n G" . consult-denote-grep))
    :config
    (consult-denote-mode 1))
#+end_src

*** TODO Consult-notes

An alternative to =consult-denote= is the similarly named =consult-note=
which seems to have much options than Prot's package. I'll give it a
try and see if =consult-denote= is still relevant for my needs, or if
=consult-note= is offering more than I actually need.

#+begin_src emacs-lisp :tangle init.el
  (use-package consult-notes
    :ensure t
    :commands (consult-notes
               consult-notes-search-in-all-notes)
    :bind
    (("C-c n f" . consult-notes)
     ("C-c n g" . consult-notes-search-in-all-notes))
    :config
    (setq consult-notes-file-dir-sources
  	'(("GTD"  ?g  "~/Documentos/gtd/")
  	  ("Notes"  ?n  "~/Documentos/notes/")
  	  ("Notes Ex aequo"  ?e  "~/Documentos/notes-exaequo/"))) ;; Set notes dir(s), see below
    ;; Set org-roam integration, denote integration, or org-heading integration e.g.:
    ;; (setq consult-notes-org-headings-files '("~/path/to/file1.org"
    ;;                                          "~/path/to/file2.org"))
    ;; (consult-notes-org-headings-mode)
    ;; (when (locate-library "denote")
    ;;   (consult-notes-denote-mode))
    ;; search only for text files in denote dir
    (setq consult-notes-denote-files-function (lambda () (denote-directory-files nil t t))))
#+end_src

*** Denote-silo

Considering I'm using multiple directories to take notes, silos are a
useful tool to manage them. I also use a specific silo to make it
easier to tag my pictures, since I can use the function to infer
keywords from preexisting files in the directory.

#+begin_src emacs-lisp :tangle init.el
  (use-package denote-silo
    :ensure t
    ;; Bind these commands to key bindings of your choice.
    ;; :commands ( denote-silo-create-note
    ;;             denote-silo-open-or-create
    ;;             denote-silo-select-silo-then-command
    ;;             denote-silo-dired
    ;;             denote-silo-cd )
    :bind
    (("C-c n s n" . denote-silo-create-note)
     ("C-c n s o" . denote-silo-open-or-create)
     ("C-c n s s" . denote-silo-select-silo-then-command)
     ("C-c n s d" . denote-silo-dired)
     ("C-c n s c" . denote-silo-cd))
    :config
    ;; Add your silos to this list.  By default, it only includes the
    ;; value of the variable `denote-directory'.
    (setq denote-silo-directories
          (list denote-directory
                "~/Documentos/notes/"
                "~/Documentos/notes-exaequo/"
  	      "~/Imágenes/")))
#+end_src

*** TODO Denote Org

#+begin_src emacs-lisp :tangle init.el
  (use-package denote-org
    :ensure t
    :commands
    ;; I list the commands here so that you can discover them more
    ;; easily.  You might want to bind the most frequently used ones to
    ;; the `org-mode-map'.
    ( denote-org-link-to-heading
      denote-org-backlinks-for-heading

      denote-org-extract-org-subtree

      denote-org-convert-links-to-file-type
      denote-org-convert-links-to-denote-type

      denote-org-dblock-insert-files
      denote-org-dblock-insert-links
      denote-org-dblock-insert-backlinks
      denote-org-dblock-insert-missing-links
      denote-org-dblock-insert-files-as-headings))
#+end_src

*** Denote journal

A package to manage a daily journal with Denote. I'm still not sure I
want to use this, but for the moment, here is the default
configuration with my own keybindings.

#+begin_src emacs-lisp :tangle init.el
  (use-package denote-journal
    :ensure t
    ;; Bind those to some key for your convenience.
    :commands ( denote-journal-new-entry
                denote-journal-new-or-existing-entry
                denote-journal-link-or-create-entry )
    :bind
    (("C-c n j n" . denote-journal-new-entry)
     ("C-c n j o" . denote-journal-new-or-existing-entry)
     ("C-c n j l" . denote-journal-link-or-create-entry))
    :hook (calendar-mode . denote-journal-calendar-mode)
    :config
    ;; Use the "journal" subdirectory of the `denote-directory'.  Set this
    ;; to nil to use the `denote-directory' instead.
    (setq denote-journal-directory
          (expand-file-name "journal" denote-directory))
    ;; Default keyword for new journal entries. It can also be a list of
    ;; strings.
    (setq denote-journal-keyword "journal")
    ;; Read the doc string of `denote-journal-title-format'.
    (setq denote-journal-title-format 'day-date-month-year))
#+end_src

** TODO Citar

*** TODO General configuration

#+begin_src emacs-lisp :tangle init.el
  (use-package citar
    :ensure t
    :demand t
    :after all-the-icons
    :init
    (defvar citar-indicator-files-icons
      (citar-indicator-create
       :symbol (all-the-icons-faicon
  	      "file-o"
  	      :face 'all-the-icons-green
  	      :v-adjust -0.1)
       :function #'citar-has-files
       :padding "  "
       :tag "has:files"))

    (defvar citar-indicator-links-icons
      (citar-indicator-create
       :symbol (all-the-icons-octicon
  	      "link"
  	      :face 'all-the-icons-orange
  	      :v-adjust 0.01)
       :function #'citar-has-links
       :padding "  "
       :tag "has:links"))

    (defvar citar-indicator-notes-icons
      (citar-indicator-create
       :symbol (all-the-icons-material
  	      "speaker_notes"
  	      :face 'all-the-icons-blue
  	      :v-adjust -0.3)
       :function #'citar-has-notes
       :padding "  "
       :tag "has:notes"))

    (defvar citar-indicator-cited-icons
      (citar-indicator-create
       :symbol (all-the-icons-faicon
                "circle-o"
                :face 'all-the-icon-green)
       :function #'citar-is-cited
       :padding "  "
       :tag "is:cited"))
    
    :hook
    ;; set up citation completion for latex, org-mode, and markdown
    (LaTeX-mode . citar-capf-setup)
    (org-mode . citar-capf-setup)
    (markdown-mode . citar-capf-setup)
    
    :config
    (setq citar-indicators
          (list citar-indicator-files-icons
                citar-indicator-links-icons
                citar-indicator-notes-icons
                citar-indicator-cited-icons))
    :custom
    (citar-bibliography '("~/Documentos/library/library.bib"))
    :custom
    (org-cite-global-bibliography '("~/Documentos/library/library.bib"))
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)
    ;; optional: org-cite-insert is also bound to C-c C-x C-@
    :bind
    (:map org-mode-map :package org ("C-c b b" . #'org-cite-insert))
    :bind
    (("C-c b o" . citar-open)))
#+end_src

*** TODO Citar and Denote

My configuration is heavily inspired by Peter Provos work, as
described in [[https://lucidmanager.org/productivity/bibliographic-notes-in-emacs-with-citar-denote/][Bibliographic Notes with the Citar-Denote Emacs Package]]
as well as in his book Emacs Writing Studio.

#+begin_src emacs-lisp :tangle init.el
  (use-package citar-denote
    :ensure t
    :custom
    (citar-open-always-create-notes t)
    :init
    (citar-denote-mode)
    :bind
    (("C-c b c" . citar-create-note)
     ("C-c b n" . citar-denote-open-note)
     ("C-c b x" . citar-denote-nocite)
     :map org-mode-map
     ("C-c b k" . citar-denote-add-citekey)
     ("C-c b K" . citar-denote-remove-citekey)
     ("C-c b d" . citar-denote-dwim)
     ("C-c b e" . citar-denote-open-reference-entry)))
#+end_src

To make sure we have the best performance with =citar-denote=, it's
recommended to use ripgrep for the =xref= system.

#+begin_src emacs-lisp :tangle init.el
  (setq xref-search-program #'ripgrep)
#+end_src

*** TODO Consult and notes

*** TODO Citar and embark

#+begin_src emacs-lisp :tangle init.el
  (use-package citar-embark
    :ensure t
    :after (citar embark)
    :no-require
    :config (citar-embark-mode))
#+end_src

** Biblio
A small package to query metadata from a DOI. There is nothing else to
be configured.

#+begin_src emacs-lisp :tangle init.el
  (use-package biblio
    :ensure t)
#+end_src

** TODO Recutils (=rec-mode=)

#+begin_src emacs-lisp :tangle init.el
  (use-package rec-mode
    :ensure t)
#+end_src

** TODO Themes

*** TODO Ef themes

When I want some change from =modus-themes=, =ef-themes= are my favorites
alternatives. This configuration is taken from Prot's dotfiles. I
appreciate how he decided to make titles bigger depending on their
relative importance and I think it is something I will try to
implement by default with the =modus-themes= too.

#+begin_src emacs-lisp :tangle init.el
  (use-package ef-themes
    :ensure t
    :demand t
    :bind
    (("<f5>" . ef-themes-rotate)
     ("C-<f5>" . ef-themes-select))
    :config
    (setq ef-themes-variable-pitch-ui t
          ef-themes-mixed-fonts t
          ef-themes-to-rotate ef-themes-items
          ef-themes-headings ; read the manual's entry of the doc string
          '((0 . (variable-pitch light 1.9))
            (1 . (variable-pitch light 1.8))
            (2 . (variable-pitch regular 1.7))
            (3 . (variable-pitch regular 1.6))
            (4 . (variable-pitch regular 1.5))
            (5 . (variable-pitch 1.4)) ; absence of weight means `bold'
            (6 . (variable-pitch 1.3))
            (7 . (variable-pitch 1.2))
            (agenda-date . (semilight 1.5))
            (agenda-structure . (variable-pitch light 1.9))
            (t . (variable-pitch 1.1)))))
#+end_src
*** TODO Doric themes
#+begin_src emacs-lisp :tangle init.el
(use-package doric-themes
  :ensure t
  :demand t
  :config
  ;; These are the default values.
  (setq doric-themes-to-toggle '(doric-light doric-dark))
  (setq doric-themes-to-rotate doric-themes-collection)

  (doric-themes-select 'doric-light)

  ;; ;; To load a random theme instead, use something like one of these:
  ;;
  ;; (doric-themes-load-random)
  ;; (doric-themes-load-random 'light)
  ;; (doric-themes-load-random 'dark)

  ;; ;; For optimal results, also define your preferred font family (or use my `fontaine' package):
  ;;
  ;; (set-face-attribute 'default nil :family "Aporetic Sans Mono" :height 160)
  ;; (set-face-attribute 'variable-pitch nil :family "Aporetic Sans" :height 1.0)
  ;; (set-face-attribute 'fixed-pitch nil :family "Aporetic Sans Mono" :height 1.0)

  :bind
  (("<f5>" . doric-themes-toggle)
   ("C-<f5>" . doric-themes-select)
   ("M-<f5>" . doric-themes-rotate)))
#+end_src
*** TODO COMMENT Theme-buffet

To explore, but allows to automatically switch themes.

#+begin_src emacs-lisp :tangle init.el
  (use-package theme-buffet
        :after (modus-themes ef-themes)  ; add your favorite themes here
        :init
        ;; variable below needs to be set when you just want to use the timers mins/hours
        (setq theme-buffet-menu 'modus-ef) ; changing default value from built-in to modus-ef
        :config
        ;;; one of the three below can be uncommented
        ;; (theme-buffet-modus-ef)
        ;; (theme-buffet-built-in)
        ;; (theme-buffet-end-user)
        ;;; two additional timers are available for theme change, both can be set
        (theme-buffet-timer-mins 25)  ; change theme every 25m from now, similar below
        (theme-buffet-timer-hours 2))
#+end_src

** Modeline

For now, until I feel more comfortable playing with the modeline, I'm
planning on using Doom modeline. I don't have much settings to change
from the default configuration, so I keep it /as is/.

#+begin_src emacs-lisp :tangle init.el
(use-package doom-modeline
  :ensure t
  :hook (after-init . doom-modeline-mode))
#+end_src

** TODO External packages for Dired
*** dired-preview

#+begin_src emacs-lisp :tangle init.el
  (use-package dired-preview
    :ensure t
    :hook (dired . dired-preview)
    :config
    (setq dired-preview-delay 0.7
  	  dired-preview-max-size (expt 6 20)
  	  dired-preview-ignored-extensions-regexp (concat "\\."
  							  "\\(gz\\|"
  							  "zst\\|"
  							  "tar\\|"
  							  "xz\\|"
  							  "rar\\|"
  							  "zip\\|"
  							  "iso\\|"
  							  "epub"
  							  "\\)"))

    ;; Enable `dired-preview-mode' in a given Dired buffer or do it ;; globally:
    (dired-preview-global-mode 1))
#+end_src
*** all-the-icons-dired

To make dired a bit more approchable with some nice icons.

#+begin_src emacs-lisp :tangle init.el
  (use-package all-the-icons-dired
    :ensure t
    :hook (dired-mode))
#+end_src
*** dired-subtree

Now a package I use a lot, but it can be useful when making a lot of
changes at the same time in multiple directories or to scan them
quickly.

#+begin_src emacs-lisp :tangle init.el
  (use-package dired-subtree
    :ensure t
    :after dired
    :bind
    ( :map dired-mode-map
      ("<tab>" . dired-subtree-toggle)
      ("TAB" . dired-subtree-toggle)
      ("<backtab>" . dired-subtree-remove)
      ("S-TAB" . dired-subtree-remove))
    :config
    (setq dired-subtree-use-backgrounds nil))
#+end_src

** TODO Minibuffer
*** TODO Vertico

Vertico has been my favorite package to expand vertically the
minibuffer.

#+begin_src emacs-lisp :tangle init.el
  ;; Enable Vertico.
  (use-package vertico
    :ensure t
    :custom
    ;; (vertico-scroll-margin 0) ;; Different scroll margin
    ;; (vertico-count 20) ;; Show more candidates
    ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode))
#+end_src

*** TODO Orderless

An essential external package. Allows to have more relevant results
when searching for something since order is not an issue anymore.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides
     '((file (styles partial-completion)))))
#+end_src

*** TODO Marginalia

#+begin_src emacs-lisp :tangle init.el
  (use-package marginalia
    :ensure t
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init section is always executed.
    :init

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    (marginalia-mode))
#+end_src

*** TODO Consult

#+begin_src emacs-lisp :tangle init.el
  ;; Example configuration for Consult
  (use-package consult
    :ensure t
    ;; Replace bindings. Lazily loaded by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g r" . consult-grep-match)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Tweak the register preview for `consult-register-load',
    ;; `consult-register-store' and the built-in commands.  This improves the
    ;; register formatting, adds thin separator lines, register sorting and hides
    ;; the window mode line.
    (advice-add #'register-preview :override #'consult-register-window)
    (setq register-preview-delay 0.5)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep consult-man
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
  )
#+end_src

** TODO Org-mode

*** TODO Org-tempo

This package allows us to add a few more templates to write
quickly environments in an org file. The most important is "cel",
helping me to write the current document.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package org-tempo
    :after org
    :config
    (dolist (item '(("sh" . "src shell")
		    ("el" . "src emacs-lisp")
		    ("cel" . "src emacs-lisp :tangle init.el")
		    ("cco" . "src conf :tangle DIR")
		    ("py" . "src python")))
      (add-to-list 'org-structure-template-alist item)))
#+end_src

*** TODO Org-modern

This package improves the general look of Org.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-modern
    :ensure t
    ;; :custom
    ;; (org-modern-table nil)
    ;; (org-modern-keyword nil)
    ;; (org-modern-timestamp nil)
    ;; (org-modern-priority nil)
    ;; (org-modern-checkbox nil)
    ;; (org-modern-tag nil)
    ;; (org-modern-block-name nil)
    ;; (org-modern-keyword nil)
    ;; (org-modern-footnote nil)
    ;; (org-modern-internal-target nil)
    ;; (org-modern-radio-target nil)
    ;; (org-modern-statistics nil)
    ;; (org-modern-progress nil)
    :hook
    (org-mode . org-modern-mode))
#+end_src

*** Org-appear

A small package that makes it easier to edit text with formating in
Org.

#+begin_src emacs-lisp :tangle init.el
  ;; Show hidden emphasis markers

  (use-package org-appear
    :ensure t
    :hook
    (org-mode . org-appear-mode))
#+end_src

*** TODO Org-web-tools

This package offers a very good tool to easily create links with the
actual name of the web page, but offers additional actions to create
org files out of website. Could be useful in the future, but I'll need
to investigate more. See [[https://github.com/alphapapa/org-web-tools][GitHub - alphapapa/org-web-tools: View,
capture, and archive Web pages in Org-mode]].

#+begin_src emacs-lisp :tangle init.el
  ;; Easy insertion of weblinks

  (use-package org-web-tools
    :ensure t
    :bind
    (("C-c w" . org-web-tools-insert-link-for-url)))
#+end_src

** TODO Other
*** TODO Embark
#+begin_src emacs-lisp :tangle init.el
  (use-package embark
    :ensure t

    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc. You may adjust the
    ;; Eldoc strategy, if you want to see the documentation from
    ;; multiple providers. Beware that using this can be a little
    ;; jarring since the message shown in the minibuffer can be more
    ;; than one line, causing the modeline to move up and down:

    ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

    ;; Add Embark to the mouse context menu. Also enable `context-menu-mode'.
    ;; (context-menu-mode 1)
    ;; (add-hook 'context-menu-functions #'embark-context-menu 100)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
*** TODO Spacious-padding

Other package by Prot, this one improves the look of Emacs (and
readability) by adding padding as the name implies.

#+begin_src emacs-lisp :tangle init.el
  (use-package spacious-padding
    :ensure t
    :custom
    (line-spacing 3)
    (setq spacious-padding-widths
          `( :internal-border-width 15
             :header-line-width 4
             :mode-line-width 6
             :tab-width 4
             :right-divider-width 15
             :scroll-bar-width ,(if x-toolkit-scroll-bars 8 6)
             :left-fringe-width 20
             :right-fringe-width 20))
    (setq spacious-padding-subtle-frame-lines
          '( :mode-line-active spacious-padding-line-active
             :mode-line-inactive spacious-padding-line-inactive
             :header-line-active spacious-padding-line-active
             :header-line-inactive spacious-padding-line-inactive))
    :init
    (spacious-padding-mode 1))
#+end_src
*** TODO Olivetti
#+begin_src emacs-lisp :tangle init.el
  (use-package olivetti
    :ensure t
    :bind
    ("C-c o" . olivetti-mode)
    :custom
    (olivetti-style 'fancy))
#+end_src
*** TODO COMMENT Beframe

Eventually I would like to give ~beframe~ a try, but for now, this is
only Prot's configuration I'll need to dig into.

#+begin_src emacs-lisp :tangle init.el
  (use-package beframe
    :ensure t
    :hook (after-init . beframe-mode)
    :config
    (setq beframe-functions-in-frames '(project-prompt-project-dir))

    ;; I use this instead of :bind because I am binding a keymap and the
    ;; way `use-package' does it is by wrapping a lambda around it that
    ;; then breaks `describe-key' for those keys.
    (prot-emacs-keybind global-map
  		      ;; Override the `set-fill-column' that I have no use for.
  		      "C-x f" #'other-frame-prefix
  		      ;; Bind Beframe commands to a prefix key. Notice the -map as I am
  		      ;; binding keymap here, not a command.
  		      "C-c b" #'beframe-prefix-map
  		      ;; Replace the generic `buffer-menu'.  With a prefix argument, this
  		      ;; commands prompts for a frame.  Call the `buffer-menu' via M-x if
  		      ;; you absolutely need the global list of buffers.
  		      "C-x C-b" #'beframe-buffer-menu
  		      ;; Not specific to Beframe, but since it renames frames (by means
  		      ;; of `beframe-mode') it is appropriate to have this here:
  		      "C-x B" #'select-frame-by-name)

    ;; Integration with the `consult-buffer' command.  It will show only
    ;; buffers from the current frame.  To view all buffers, first input
    ;; a space at the empty minibuffer prompt.  This enables the "hidden
    ;; buffers" view.
    (with-eval-after-load 'consult
      (defun consult-beframe-buffer-list (&optional frame)
        "Return the list of buffers from `beframe-buffer-names' sorted by visibility.
  With optional argument FRAME, return the list of buffers of FRAME.

  For use in `consult-buffer-list'."
        (beframe-buffer-list frame :sort #'beframe-buffer-sort-visibility))

      (setq consult-buffer-list #'consult-beframe-buffer-list)))
#+end_src
*** TODO Jinx
#+begin_src emacs-lisp :tangle init.el
  (use-package jinx
    :ensure t
    :hook (emacs-startup . global-jinx-mode)
    :bind (("M-$" . jinx-correct)
           ("C-M-$" . jinx-languages))
    :config
    (setq jinx-languages "fr_CA es_CO en_CA"))
#+end_src
*** TODO Elfeed

Probably my favorite RSS reader. There is still some work to be done
to make sure I can synchronize the data between computers.

#+begin_src emacs-lisp :tangle init.el

  ;; Read RSS feeds with Elfeed

  (use-package elfeed
    :ensure t
    :custom
    (elfeed-db-directory
     (expand-file-name "elfeed" user-emacs-directory))
    (elfeed-show-entry-switch 'switch-to-buffer)
    :bind
    ("C-c e" . elfeed))

  ;; Configure Elfeed with org mode

  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org)
    :custom
    (rmh-elfeed-org-files
     (list (concat (file-name-as-directory (getenv "HOME")) "/.emacs.d/elfeed/elfeed.org"))))

  ;; Allow better synchronization
  ;; See http://babbagefiles.blogspot.com/2017/03/take-elfeed-everywhere-mobile-rss.html

  ;;functions to support syncing .elfeed between machines
  ;;makes sure elfeed reads index from disk before launching
  (defun bjm/elfeed-load-db-and-open ()
    "Wrapper to load the elfeed db from disk before opening"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force)
    (elfeed-update))

  ;;write to disk when quiting
  (defun bjm/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

#+end_src
*** TODO Tempel


#+begin_src emacs-lisp :tangle init.el
  ;; Configure Tempel
  (use-package tempel
    ;; Require trigger prefix before template name when completing.
    ;; :custom
    ;; (tempel-trigger-prefix "<")

    :ensure t
    
    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
           ("M-*" . tempel-insert))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
                  (cons #'tempel-expand
                        completion-at-point-functions)))

    (add-hook 'conf-mode-hook 'tempel-setup-capf)
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (global-tempel-abbrev-mode)
  )

  ;; Optional: Add tempel-collection.
  ;; The package is young and doesn't have comprehensive coverage.
  (use-package tempel-collection
    :ensure t)

  ;; Optional: Use the Corfu completion UI
  (use-package corfu
    :ensure t
    :init
    (global-corfu-mode))
#+end_src
** TODO Filetype specifics

*** TODO PDF

I do use PDFs regurarly and I appreciate the ability to access them
easily in Emacs. PDF-tools is particularly useful on Linux.

#+begin_src emacs-lisp :tangle init.el
  (when (eq system-type 'gnu/linux)	;For now, pdf-tools can't be installed on Windows
    (use-package pdf-tools
      :ensure t
      :config
      (pdf-tools-install)
      (setq-default pdf-view-display-size 'fit-page)
      :bind (:map pdf-view-mode-map
  		("\\" . hydra-pdftools/body)
  		("<s-spc>" .  pdf-view-scroll-down-or-next-page)
  		("g"  . pdf-view-first-page)
  		("G"  . pdf-view-last-page)
  		("l"  . image-forward-hscroll)
  		("h"  . image-backward-hscroll)
  		("j"  . pdf-view-next-page)
  		("k"  . pdf-view-previous-page)
  		("e"  . pdf-view-goto-page)
  		("u"  . pdf-view-revert-buffer)
  		("al" . pdf-annot-list-annotations)
  		("ad" . pdf-annot-delete)
  		("aa" . pdf-annot-attachment-dired)
  		("am" . pdf-annot-add-markup-annotation)
  		("at" . pdf-annot-add-text-annotation)
  		("y"  . pdf-view-kill-ring-save)
  		("i"  . pdf-misc-display-metadata)
  		("s"  . pdf-occur)
  		("b"  . pdf-view-set-slice-from-bounding-box)
  		("r"  . pdf-view-reset-slice))))
#+end_src

Emacs Writing Studio has good default settings for Doc-view, which
can be used on Windows or if there are issues with PDF-view. I'm
taking them as is.

#+begin_src emacs-lisp :tangle init.el
  (use-package doc-view
    :ensure nil
    :custom
    (doc-view-resolution 300)
    (large-file-warning-threshold (* 50 (expt 2 20))))
#+end_src

*** TODO Epub

For Epub files there is realistically only one good package to read
them, and it's =nov=. I'm again taking the settings from Emacs Writing
Studio but I think some improvements could be made to make sure it
only load when Epub files are opened.

#+begin_src emacs-lisp :tangle init.el
  (use-package nov
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src

*** TODO Odt

I sometimes have to deal with Odt files, so this can be useful, though
I have to investigate into it. The configuration is taken from Emacs
Writing Studio.

#+begin_src emacs-lisp :tangle init.el
  ;; Reading LibreOffice files
  ;; Fixing a bug in Org Mode pre 9.7
  ;; Org mode clobbers associations with office documents

  (use-package ox-odt
    :ensure nil
    :config
    (add-to-list 'auto-mode-alist
                 '("\\.\\(?:OD[CFIGPST]\\|od[cfigpst]\\)\\'"
                   . doc-view-mode-maybe)))
#+end_src
