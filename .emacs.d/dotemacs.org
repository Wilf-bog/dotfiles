#+title: Emacs configuration
#+author: Frédéric Vachon
#+property: header-args:emacs-lisp :mkdirp yes
#+startup: content indent

This is a new configuration for my own personal use of Emacs starting
on September 1st of 2025. After a few years of playing with Emacs,
using distributions, and copying code from a variety of sources, I've
decided it was finally time to start afresh and actually write my very
own personal configuration. I'll probably keep on integrating code
from other configurations, but the goal is to be more careful and
meticulous in my use of external code. Hopefully, this configuration
will remain short enough to be manageable for me, considering my
limited time and abilities. This whole decision is partly inspired by
Jake's video on Emacs Bankruptcy which can be watched here: [[https://www.youtube.com/watch?v=dSlMmCD5quc&t=200s][Emacs
bankruptcy – fix your Emacs and your life]].

This configuration takes inspiration of a few Emacs users I've been
following over the years and I would like to thank them for their
contribution.
- Protesilaos Stravou

* TODO Early initialisation of Emacs (=early-init.el=)

This is a new concept to me as I didn't use an =early-init.el= file
before. From my understanding, since Emacs 27, this file is used to
push configuration that are loaded very early during Emacs'
initialization.

I took heavy inspiration (understand, copying) from Prot's own
configuration here, removing what seems to be pertinent in my own
situation. I kept some settings useful in a tiling window manager
configuration, like frame-resize-pixelwise, even though I tend to only
use Gnome these days. Sway may make a return someday and I would
rather avoid having to play with these settings later on.

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq frame-resize-pixelwise t
        frame-title-format '("%b")	; Name of file as the title of the frame
        use-file-dialog nil
        use-short-answers t
        inhibit-startup-screen t
        inhibit-x-resources t
        inhibit-startup-echo-area-message user-login-name
        inhibit-startup-buffer-menu t
        visible-bell t
        )
#+end_src

To make things faster at startup and for my own personal preferences,
I disable early on the GUI parts of emacs.

#+begin_src emacs-lisp :tangle "early-init.el"
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars . nil) default-frame-alist)
#+end_src

This is mysterious for me, but these settings for garbage-collection
should help with faster boot time.

#+begin_src emacs-lisp :tangle "early-init.el"
(setq gc-cons-threshold (* 10 128 1024 1024))
(setq garbage-collection-messages nil)
#+end_src

Some settings related to packages, taken directly from crafted-emacs modules about early-init.

#+begin_src emacs-lisp :tangle early-init.el

  (require 'package)

  ;;; Setup Emacs Lisp Package Archives (ELPAs)
  ;; where to get packages to install
  (when (version< emacs-version "28")
    (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/")))
  (add-to-list 'package-archives '("stable" . "https://stable.melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

  ;;; Configure ELPA priorities
  ;; Prefer GNU sources and stable versions before development versions from MELPA.
  (customize-set-variable 'package-archive-priorities
                          '(("gnu"    . 99)   ; prefer GNU packages
                            ("nongnu" . 80)   ; use non-gnu packages if
                                          ; not found in GNU elpa
                            ("stable" . 70)   ; prefer "released" versions
                                          ; from melpa
                            ("melpa"  . 0)))  ; if all else fails, get it
                                          ; from melpa
#+end_src

* TODO Emacs settings (=init.el=)

In this larger part of my configuration, I list out all the settings
that are part of the normal initialisation process.

** TODO Setting Use-package
#+begin_src emacs-lisp :tangle init.el
  ;; Built-in since Emacs 29
  (require 'use-package)
#+end_src

** TODO Emacs essential settings

To use vertico at its fullest, it's better to set this package so
history isn't lost when restarting Emacs.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package savehist
    :init
    (savehist-mode))
#+end_src

Again for Vertico, we do need to change some configuration.

#+begin_src emacs-lisp :tangle init.el
;; Emacs minibuffer configurations.
(use-package emacs
  :custom
  ;; Enable context menu. `vertico-multiform-mode' adds a menu in the minibuffer
  ;; to switch display modes.
  (context-menu-mode t)
  ;; Support opening new minibuffers from inside existing minibuffers.
  (enable-recursive-minibuffers t)
  ;; Hide commands in M-x which do not work in the current mode.  Vertico
  ;; commands are hidden in normal buffers. This setting is useful beyond
  ;; Vertico.
  (read-extended-command-predicate #'command-completion-default-include-p)
  ;; Do not allow the cursor in the minibuffer prompt
  (minibuffer-prompt-properties
   '(read-only t cursor-intangible t face minibuffer-prompt)))
#+end_src

Considering I work on multiple machines, sometimes at the same time,
and that I rely on Git for many config files, I prefer to
automatically revert the buffers I'm using (files and dired buffers
for example.

** Emacs custom-file

Departing from Emacs Writing Studio defaults, I prefer to stop using
Emacs' config file way of managing settings. Like Prot, I ask Emacs to
rely a temporary file that won't be automatically reloaded.

#+begin_src emacs-lisp :tangle "init.el"
(setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** TODO Emacs windows settings

I used to use a =M-o= to switch window quickly but in line with my
goal of keeping things minimal and to stay close to Emacs' defaults, I
want to get used to =C-x o=. I also used to use a package called
=balanced-windows= but again I'm tempted to stay away from it for the
moment, and get used to the command =C-x +=.
#+begin_src emacs-lisp :tangle "init.el"

#+end_src

** Emacs tabs

I used to use tabs with the defaults options, which means the tabs are
shown when used, and a button is used to delete tabs and another, to
create a new one. By digging into Prot's configurations, I found out
that it could be better to hide those buttons to avoid using the mouse
for tabs management and learning the correct keybindings. We will see
if it is actually useful since I do intend on trying to use Prot's
package ~beframe~.

#+begin_src emacs-lisp :tangle init.el
  (use-package tab-bar
    :ensure nil
    :config
    (setq tab-bar-new-button-show nil)
    (setq tab-bar-close-button-show nil)
    (setq tab-bar-show 1))
#+end_src

** TODO Usepackage settings

For the moment, my configuration rely only on usepackage that I find
intuiive. I do usually rely on MELPA for certain packages.

#+begin_src emacs-lisp :tangle "init.el"
  ;; Set package archives

  (use-package package
    :config
    (add-to-list 'package-archives
                 '("melpa" . "https://melpa.org/packages/"))
    (package-initialize))

  ;; Package Management

  (use-package use-package
    :custom
    (use-package-always-ensure nil)	; older config had it true.
    (package-native-compile t)
    (warning-minimum-level :emergency))
#+end_src

** TODO Emacs theme settings

To avoid getting asked about trusting themes, we can tell it to treat
all themes as safe by default. I use only a few themes.

#+begin_src emacs-lisp :tangle "init.el"
  (setq custom-safe-themes t)
#+end_src

For now, I'm running =modus-vivendi-tinted=. I do intend on
reimplementing a function to automatically switch between a dark and
light theme depending on GNOME's settings.

#+begin_src emacs-lisp :tangle "init.el"
  (load-theme 'modus-vivendi-tinted :no-confirm)
#+end_src

** TODO Recent files

#+begin_src emacs-lisp :tangle init.el
  ;; Recent files

  (use-package recentf
    :config
    (recentf-mode t)
    (run-at-time nil (* 5 60)
                 (lambda () (let ((save-silently t))
                              (recentf-save-list))))
    :custom
    (recentf-max-saved-items 50)
    :bind
    (("C-c w r" . recentf-open)))
#+end_src

* TODO External packages settings (=init.el=)

I decided to create a separate section this from the precedent to keep
a closer eye on the specific packages I'm adding to my
configuration. We will see if this will remain a sensible option as
the configuration grows.

** TODO Git

For git, I tend to prefer Magit even though it is probably overkill
considering my limited use of git in general. I do enjoy how the tool
is structured and until I take the time to learn emacs own way of
managing git and other software like this, I'll keep on using Magit.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package magit
    :ensure t)

  (add-hook 'magit-process-find-password-functions
  	  'magit-process-password-auth-source)
#+end_src

** TODO Denote
*** TODO Denote general configuration
#+begin_src emacs-lisp :tangle init.el
  ;; Remember that the website version of this manual shows the latest
  ;; developments, which may not be available in the package you are
  ;; using.  Instead of copying from the web site, refer to the version
  ;; of the documentation that comes with your package.  Evaluate:
  ;;
  ;;     (info "(denote) Sample configuration")
  (use-package denote
    :ensure t
    :hook
    ( ;; If you use Markdown or plain text files, then you want to make
     ;; the Denote links clickable (Org renders links as buttons right
     ;; away)
     (text-mode . denote-fontify-links-mode-maybe)
     ;; Apply colours to Denote names in Dired.  This applies to all
     ;; directories.  Check `denote-dired-directories' for the specific
     ;; directories you may prefer instead.  Then, instead of
     ;; `denote-dired-mode', use `denote-dired-mode-in-directories'.
     (dired-mode . denote-dired-mode))
    :bind
    ;; Denote DOES NOT define any key bindings.  This is for the user to
    ;; decide.  For example:
    ( :map global-map
      ("C-c n n" . denote)
      ("C-c n d" . denote-dired)
      ("C-c n g" . denote-grep)
      ;; If you intend to use Denote with a variety of file types, it is
      ;; easier to bind the link-related commands to the `global-map', as
      ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
      ;; `markdown-mode-map', and/or `text-mode-map'.
      ("C-c n l" . denote-link)
      ("C-c n L" . denote-add-links)
      ("C-c n b" . denote-backlinks)
      ("C-c n q c" . denote-query-contents-link) ; create link that triggers a grep
      ("C-c n q f" . denote-query-filenames-link) ; create link that triggers a dired
      ;; Note that `denote-rename-file' can work from any context, not just
      ;; Dired bufffers.  That is why we bind it here to the `global-map'.
      ("C-c n r" . denote-rename-file)
      ("C-c n R" . denote-rename-file-using-front-matter)

      ;; Key bindings specifically for Dired.
      :map dired-mode-map
      ("C-c C-d C-i" . denote-dired-link-marked-notes)
      ("C-c C-d C-r" . denote-dired-rename-files)
      ("C-c C-d C-k" . denote-dired-rename-marked-files-with-keywords)
      ("C-c C-d C-R" . denote-dired-rename-marked-files-using-front-matter))

    :config
    ;; Remember to check the doc string of each of those variables.
    (setq denote-directory (expand-file-name "~/Documents/notes/"))
    (setq denote-save-buffers nil)
    (setq denote-known-keywords '("emacs" "philosophy" "politics" "economics"))
    (setq denote-infer-keywords t)
    (setq denote-sort-keywords t)
    (setq denote-prompts '(title keywords))
    (setq denote-excluded-directories-regexp nil)
    (setq denote-excluded-keywords-regexp nil)
    (setq denote-rename-confirmations '(rewrite-front-matter modify-file-name))

    ;; Pick dates, where relevant, with Org's advanced interface:
    (setq denote-date-prompt-use-org-read-date t)

    ;; Automatically rename Denote buffers using the `denote-rename-buffer-format'.
    (denote-rename-buffer-mode 1))
#+end_src
*** TODO 

** TODO Dired
#+begin_src emacs-lisp :tangle init.el
  (use-package dired-preview
    :ensure t
    :hook (dired . dired-preview)
    :config
    (setq dired-preview-delay 0.7
  	  dired-preview-max-size (expt 6 20)
  	  dired-preview-ignored-extensions-regexp (concat "\\."
  							  "\\(gz\\|"
  							  "zst\\|"
  							  "tar\\|"
  							  "xz\\|"
  							  "rar\\|"
  							  "zip\\|"
  							  "iso\\|"
  							  "epub"
  							  "\\)"))

    ;; Enable `dired-preview-mode' in a given Dired buffer or do it ;; globally:
    (dired-preview-global-mode 1))
#+end_src
** TODO Minibuffer
*** TODO Vertico

#+begin_src emacs-lisp :tangle init.el
  ;; Enable Vertico.
  (use-package vertico
    :ensure t
    :custom
    ;; (vertico-scroll-margin 0) ;; Different scroll margin
    ;; (vertico-count 20) ;; Show more candidates
    ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode))
#+end_src

*** TODO Orderless

An essential external package. Allows to have more relevant results
when searching for something since order is not an issue anymore.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides
     '((file (styles partial-completion)))))
#+end_src

*** TODO Marginalia

#+begin_src emacs-lisp :tangle init.el
  (use-package marginalia
    :ensure t
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init section is always executed.
    :init

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    (marginalia-mode))
#+end_src

*** TODO Consult

#+begin_src emacs-lisp :tangle init.el
  ;; Example configuration for Consult
  (use-package consult
    :ensure t
    ;; Replace bindings. Lazily loaded by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g r" . consult-grep-match)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Tweak the register preview for `consult-register-load',
    ;; `consult-register-store' and the built-in commands.  This improves the
    ;; register formatting, adds thin separator lines, register sorting and hides
    ;; the window mode line.
    (advice-add #'register-preview :override #'consult-register-window)
    (setq register-preview-delay 0.5)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep consult-man
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
  )
#+end_src

** TODO Org-mode

*** TODO Org-tempo

This package allows us, at least, to add a few more templates to write
quickly environments in an org file.
#+begin_src emacs-lisp :tangle "init.el"
  (use-package org-tempo
    :after org
    :config
    (dolist (item '(("sh" . "src shell")
		    ("el" . "src emacs-lisp")
		    ("cel" . "src emacs-lisp :tangle init.el")
		    ("cco" . "src conf :tangle DIR")
		    ("py" . "src python")))
      (add-to-list 'org-structure-template-alist item)))
#+end_src

*** TODO Org-modern

This package improves the general look of Org.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-modern
    :ensure t
    :hook
    (org-mode . org-modern-mode))
#+end_src

** TODO Other
*** TODO Embark
#+begin_src emacs-lisp :tangle init.el
  (use-package embark
    :ensure t

    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc. You may adjust the
    ;; Eldoc strategy, if you want to see the documentation from
    ;; multiple providers. Beware that using this can be a little
    ;; jarring since the message shown in the minibuffer can be more
    ;; than one line, causing the modeline to move up and down:

    ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

    ;; Add Embark to the mouse context menu. Also enable `context-menu-mode'.
    ;; (context-menu-mode 1)
    ;; (add-hook 'context-menu-functions #'embark-context-menu 100)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
*** TODO Spacious-padding

Other package by Prot, this one improves the look of Emacs (and
readability) by adding padding as the name implies.

#+begin_src emacs-lisp :tangle init.el
  (use-package spacious-padding
    :ensure t
    :custom
    (line-spacing 2)
    (setq spacious-padding-widths
          `( :internal-border-width 15
             :header-line-width 4
             :mode-line-width 6
             :tab-width 4
             :right-divider-width 15
             :scroll-bar-width ,(if x-toolkit-scroll-bars 8 6)
             :left-fringe-width 20
             :right-fringe-width 20))
    (setq spacious-padding-subtle-frame-lines
          '( :mode-line-active spacious-padding-line-active
             :mode-line-inactive spacious-padding-line-inactive
             :header-line-active spacious-padding-line-active
             :header-line-inactive spacious-padding-line-inactive))
    :init
    (spacious-padding-mode 1))
#+end_src
*** TODO COMMENT Beframe

Eventually I would like to give ~beframe~ a try, but for now, this is
only Prot's configuration I'll need to dig into.

#+begin_src emacs-lisp :tangle init.el
  (use-package beframe
    :ensure t
    :hook (after-init . beframe-mode)
    :config
    (setq beframe-functions-in-frames '(project-prompt-project-dir))

    ;; I use this instead of :bind because I am binding a keymap and the
    ;; way `use-package' does it is by wrapping a lambda around it that
    ;; then breaks `describe-key' for those keys.
    (prot-emacs-keybind global-map
  		      ;; Override the `set-fill-column' that I have no use for.
  		      "C-x f" #'other-frame-prefix
  		      ;; Bind Beframe commands to a prefix key. Notice the -map as I am
  		      ;; binding keymap here, not a command.
  		      "C-c b" #'beframe-prefix-map
  		      ;; Replace the generic `buffer-menu'.  With a prefix argument, this
  		      ;; commands prompts for a frame.  Call the `buffer-menu' via M-x if
  		      ;; you absolutely need the global list of buffers.
  		      "C-x C-b" #'beframe-buffer-menu
  		      ;; Not specific to Beframe, but since it renames frames (by means
  		      ;; of `beframe-mode') it is appropriate to have this here:
  		      "C-x B" #'select-frame-by-name)

    ;; Integration with the `consult-buffer' command.  It will show only
    ;; buffers from the current frame.  To view all buffers, first input
    ;; a space at the empty minibuffer prompt.  This enables the "hidden
    ;; buffers" view.
    (with-eval-after-load 'consult
      (defun consult-beframe-buffer-list (&optional frame)
        "Return the list of buffers from `beframe-buffer-names' sorted by visibility.
  With optional argument FRAME, return the list of buffers of FRAME.

  For use in `consult-buffer-list'."
        (beframe-buffer-list frame :sort #'beframe-buffer-sort-visibility))

      (setq consult-buffer-list #'consult-beframe-buffer-list)))
#+end_src
